From e78fedfdfc0e5eba74aa96d16ee677553cfbfde4 Mon Sep 17 00:00:00 2001
From: Akihiro Suda <akihiro.suda.cz@hco.ntt.co.jp>
Date: Tue, 9 Jan 2024 17:25:04 +0900
Subject: [PATCH] [WASI-NN] Support RPC mode

RPC mode allows using another Wasi-NN instance that is running on a remote
WasmEdge instance, via `ssh -R remote.sock:local.sock`.

An example usecase is to allow Linux VM (e.g., Lima) guest to use the host GPU.

The gRPC proto can be repurposed for non-WASM applications as well.

- - -

Build
=====

Set `WASMEDGE_BUILD_WASI_NN_RPC` to `ON`.
Enabled by default when gRPC (libgrpc++-dev) is installed.

Usage
=====

Host 1 (rpc server / ssh client, e.g., Lima host with physical GPU)
-----

```
wasi_nn_rpcserver \
  --nn-rpc-uri unix:///$HOME/nn_server.sock \
  --nn-preload default:GGML:AUTO:llama-2-7b-chat.Q5_K_M.gguf

ssh \
  -R /tmp/nn_client.sock:$HOME/nn_server.sock \
  host2
```

Host 2 (rpc client / ssh server, e.g., Lima guest)
-----

```
wasmedge \
  --nn-rpc-uri unix:///tmp/nn_client.sock \
  wasmedge-ggml-llama-interactive.wasm \
  default "1 + 1 = ?"
```

See <https://github.com/second-state/WasmEdge-WASINN-examples/tree/master/wasmedge-ggml-llama-interactive>
for how to obtain `llama-2-7b-chat.Q5_K_M.gguf` and `wasmedge-ggml-llama-interactive.wasm`.

Signed-off-by: Akihiro Suda <akihiro.suda.cz@hco.ntt.co.jp>
---
 .github/workflows/build-extensions.yml        |  17 +-
 .github/workflows/release.yml                 |   2 +-
 .../workflows/reusable-build-on-fedora.yml    |   3 +-
 .github/workflows/reusable-build-on-macos.yml |   2 +-
 .../workflows/reusable-build-on-ubuntu.yml    |   4 +
 CMakeLists.txt                                |  21 ++
 cmake/Helper.cmake                            |   7 +
 include/api/wasmedge/wasmedge.h               |  14 +
 include/driver/wasiNNRPCServerTool.h          |   9 +
 .../wasi_nn_rpcserver/wasi_nn_rpcserver.h     | 308 ++++++++++++++++++
 lib/CMakeLists.txt                            |   3 +
 lib/api/CMakeLists.txt                        |   3 +
 lib/api/wasmedge.cpp                          |  13 +
 lib/driver/CMakeLists.txt                     |  17 +-
 lib/driver/wasiNNRPCServerTool.cpp            |  97 ++++++
 lib/wasi_nn_rpc/CMakeLists.txt                |  47 +++
 lib/wasi_nn_rpc/wasi_ephemeral_nn.proto       |  81 +++++
 plugins/wasi_nn/CMakeLists.txt                |  13 +
 plugins/wasi_nn/wasinnenv.cpp                 |  35 ++
 plugins/wasi_nn/wasinnenv.h                   |  10 +-
 plugins/wasi_nn/wasinnfunc.cpp                | 181 +++++++++-
 test/plugins/wasi_nn/CMakeLists.txt           |   8 +
 test/plugins/wasi_nn/wasi_nn.cpp              | 212 +++++++++++-
 tools/wasmedge/CMakeLists.txt                 |  31 ++
 tools/wasmedge/wasi_nn_rpcserver.cpp          |  20 ++
 25 files changed, 1135 insertions(+), 23 deletions(-)
 create mode 100644 include/driver/wasiNNRPCServerTool.h
 create mode 100644 include/driver/wasi_nn_rpc/wasi_nn_rpcserver/wasi_nn_rpcserver.h
 create mode 100644 lib/driver/wasiNNRPCServerTool.cpp
 create mode 100644 lib/wasi_nn_rpc/CMakeLists.txt
 create mode 100644 lib/wasi_nn_rpc/wasi_ephemeral_nn.proto
 create mode 100644 tools/wasmedge/wasi_nn_rpcserver.cpp

diff --git a/.github/workflows/build-extensions.yml b/.github/workflows/build-extensions.yml
index df235d651a4..48759e540f9 100644
--- a/.github/workflows/build-extensions.yml
+++ b/.github/workflows/build-extensions.yml
@@ -100,7 +100,7 @@ jobs:
         shell: bash
         run: |
           apt update
-          apt install -y unzip libopenblas-dev pkg-config
+          apt install -y unzip libopenblas-dev pkg-config protobuf-compiler-grpc libgrpc-dev libgrpc++-dev
           bash utils/wasi-nn/install-pytorch.sh
       - name: Build and test WASI-NN using ${{ matrix.compiler }} with ${{ matrix.build_type }} mode
         shell: bash
@@ -125,6 +125,21 @@ jobs:
             cp -f ${output_dir}/${output_bin} ${output_bin}
             tar -zcvf plugin_${plugin_array[$i]}.tar.gz ${output_bin}
           done
+      - name: Test WASI-NN RPC mode with GGML
+        shell: bash
+        run: |
+          set -eux
+          # wasi_nn_rpcserver is built in a clean "build2" dir
+          cmake -Bbuild2 -GNinja
+          cmake --build build2
+          export WASI_NN_RPC_TEST_URI=unix:///tmp/wasi_nn_rpc.sock
+          WASMEDGE_PLUGIN_PATH=build/plugins/wasi_nn build2/tools/wasmedge/wasi_nn_rpcserver \
+            --nn-rpc-uri=$WASI_NN_RPC_TEST_URI \
+            --nn-preload=default:GGML:AUTO:build/test/plugins/wasi_nn/wasinn_ggml_fixtures/orca_mini.gguf &
+          sleep 3
+          cd ${test_dir}
+          # The test binary consumes $WASI_NN_RPC_TEST_URI
+          ./${test_bin} --gtest_filter=WasiNNTest.GGMLBackendWithRPC
       - name: Upload artifact - wasi_nn-pytorch
         uses: actions/upload-artifact@v3
         with:
diff --git a/.github/workflows/release.yml b/.github/workflows/release.yml
index d840bef23a3..c7ff2a4d783 100644
--- a/.github/workflows/release.yml
+++ b/.github/workflows/release.yml
@@ -145,7 +145,7 @@ jobs:
         shell: bash
         run: |
           apt update
-          apt install -y unzip libopenblas-dev pkg-config
+          apt install -y unzip libopenblas-dev pkg-config protobuf-compiler-grpc libgrpc-dev libgrpc++-dev
           bash utils/wasi-nn/install-pytorch.sh
       - name: Build WASI-NN plugin
         shell: bash
diff --git a/.github/workflows/reusable-build-on-fedora.yml b/.github/workflows/reusable-build-on-fedora.yml
index 613ce583e99..c786edcc3bd 100644
--- a/.github/workflows/reusable-build-on-fedora.yml
+++ b/.github/workflows/reusable-build-on-fedora.yml
@@ -21,7 +21,8 @@ jobs:
       - name: Install dependency
         run: |
           dnf update -y
-          dnf install -y cmake ninja-build llvm llvm-devel lld-devel clang git file rpm-build dpkg-dev spdlog-devel
+          dnf install -y cmake ninja-build llvm llvm-devel lld-devel clang git file rpm-build dpkg-dev spdlog-devel \
+            pkgconf-pkg-config protobuf-c-compiler grpc-cpp grpc-plugins grpc-devel
       - uses: actions/checkout@v3
         with:
           fetch-depth: 0
diff --git a/.github/workflows/reusable-build-on-macos.yml b/.github/workflows/reusable-build-on-macos.yml
index af9d53c6aa4..07a8d07f30d 100644
--- a/.github/workflows/reusable-build-on-macos.yml
+++ b/.github/workflows/reusable-build-on-macos.yml
@@ -33,7 +33,7 @@ jobs:
       - name: Setup build environment
         run: |
           eval $(/opt/homebrew/bin/brew shellenv)
-          brew install llvm@16 ninja cmake wabt
+          brew install llvm@16 ninja cmake wabt grpc
       - name: Set environment variables for release
         if: ${{ inputs.release }}
         run: |
diff --git a/.github/workflows/reusable-build-on-ubuntu.yml b/.github/workflows/reusable-build-on-ubuntu.yml
index 7f6a097df91..8211391e06f 100644
--- a/.github/workflows/reusable-build-on-ubuntu.yml
+++ b/.github/workflows/reusable-build-on-ubuntu.yml
@@ -24,6 +24,10 @@ jobs:
       BUILD_TESTS: OFF
     container: wasmedge/wasmedge:${{ matrix.docker_tag }}
     steps:
+      - name: Install dependencies
+        run: |
+          apt-get update
+          apt-get install -y pkg-config protobuf-compiler-grpc libgrpc-dev libgrpc++-dev
       - uses: actions/checkout@v3
         with:
           fetch-depth: 0
diff --git a/CMakeLists.txt b/CMakeLists.txt
index c24b3c05b02..7962eaf6f98 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -13,6 +13,8 @@ set(CMAKE_MSVC_RUNTIME_LIBRARY "MultiThreadedDLL")
 
 set(WASMEDGE_CAPI_VERSION "0.1.0" CACHE STRING "WasmEdge C API library version")
 set(WASMEDGE_CAPI_SOVERSION "0" CACHE STRING "WasmEdge C API library soversion")
+set(WASMEDGE_WASI_NN_VERSION "0.1.0" CACHE STRING "WasmEdge WASI-NN library version")
+set(WASMEDGE_WASI_NN_SOVERSION "0" CACHE STRING "WasmEdge WASI-NN library soversion")
 
 find_program(GIT_CMD git)
 execute_process(COMMAND
@@ -56,6 +58,7 @@ option(WASMEDGE_BUILD_TOOLS "Generate wasmedge and wasmedgec tools. Depend on an
 option(WASMEDGE_BUILD_FUZZING "Generate fuzzing test tools. Couldn't build with wasmedge tools and unit tests." OFF)
 option(WASMEDGE_BUILD_PLUGINS "Generate plugins." ON)
 option(WASMEDGE_BUILD_EXAMPLE "Generate examples." OFF)
+option(WASMEDGE_BUILD_WASI_NN_RPC "Generate Wasi-NN RPC." OFF)
 option(WASMEDGE_FORCE_DISABLE_LTO "Forcefully disable link time optimization when linking even in Release/RelWithDeb build." OFF)
 option(WASMEDGE_LINK_LLVM_STATIC "Statically link the LLVM library into the WasmEdge tools and libraries." OFF)
 option(WASMEDGE_LINK_TOOLS_STATIC "Statically link the wasmedge and wasmedgec tools. Will forcefully link the LLVM library statically." OFF)
@@ -108,6 +111,24 @@ if(WASMEDGE_BUILD_PLUGINS)
   endif()
 endif()
 
+# * Homebrew: grpc
+# * Debian, Ubuntu: libgrpc-dev, libgrpc++-dev
+find_package(PkgConfig)
+if(PkgConfig_FOUND)
+  pkg_check_modules(gRPCPP grpc++)
+endif()
+# Do not check find_package(gRPC), because libgrpc-dev for Ubuntu 22.04 does not contain cmake files.
+# https://packages.ubuntu.com/search?keywords=libgrpc-dev
+# Do not check find_package(protobuf), because libprotobuf-dev for Ubuntu does not contain cmake files.
+# https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=1027876
+if(gRPCPP_FOUND AND WASMEDGE_BUILD_SHARED_LIB)
+  message(STATUS "Setting WASMEDGE_BUILD_WASI_NN_RPC to ON. If you see an error related to gRPC or protobuf, try setting this to OFF.")
+  set(WASMEDGE_BUILD_WASI_NN_RPC ON)
+endif()
+if(WASMEDGE_BUILD_WASI_NN_RPC AND NOT WASMEDGE_BUILD_SHARED_LIB)
+  message(FATAL_ERROR "WASMEDGE_BUILD_WASI_NN_RPC depends on WASMEDGE_BUILD_SHARED_LIB")
+endif()
+
 set(WASMEDGE_BUILD_PACKAGE "DEB;RPM" CACHE STRING "Package generate types")
 set(CPACK_PROJECT_CONFIG_FILE ${CMAKE_CURRENT_SOURCE_DIR}/cmake/cpack_config.cmake)
 
diff --git a/cmake/Helper.cmake b/cmake/Helper.cmake
index 667b1fe5a85..2b447ab2397 100644
--- a/cmake/Helper.cmake
+++ b/cmake/Helper.cmake
@@ -164,6 +164,13 @@ endfunction()
 function(wasmedge_add_library target)
   add_library(${target} ${ARGN})
   wasmedge_setup_target(${target})
+  # Linux needs an explicit INSTALL_RPATH to allow libwasmedge.so to find libwasiNNRPC.so
+  # in the same directory
+  if(CMAKE_SYSTEM_NAME MATCHES "Linux")
+    set_target_properties(${target} PROPERTIES
+      INSTALL_RPATH "$ORIGIN"
+    )
+  endif()
 endfunction()
 
 function(wasmedge_add_executable target)
diff --git a/include/api/wasmedge/wasmedge.h b/include/api/wasmedge/wasmedge.h
index 56f7331cbca..f32471640ef 100644
--- a/include/api/wasmedge/wasmedge.h
+++ b/include/api/wasmedge/wasmedge.h
@@ -3873,6 +3873,20 @@ WASMEDGE_CAPI_EXPORT extern int WasmEdge_Driver_Compiler(int Argc,
 WASMEDGE_CAPI_EXPORT extern int WasmEdge_Driver_Tool(int Argc,
                                                      const char *Argv[]);
 
+#ifdef WASMEDGE_BUILD_WASI_NN_RPC
+/// Entrypoint for the Wasi-NN RPC server tool.
+///
+/// This function provides an entrypoint to the WasmEdge Wasi-NN RPC server tool
+/// with the command line arguments.
+///
+/// \param Argc the argument count.
+/// \param Argv the argument vector.
+///
+/// \returns the execution status.
+WASMEDGE_CAPI_EXPORT extern int
+WasmEdge_Driver_WasiNNRPCServer(int Argc, const char *Argv[]);
+#endif
+
 /// Entrypoint for the unified tool.
 ///
 /// This function provides an entrypoint to the WasmEdge unified tool with the
diff --git a/include/driver/wasiNNRPCServerTool.h b/include/driver/wasiNNRPCServerTool.h
new file mode 100644
index 00000000000..1ce14a07f45
--- /dev/null
+++ b/include/driver/wasiNNRPCServerTool.h
@@ -0,0 +1,9 @@
+#pragma once
+
+namespace WasmEdge {
+namespace Driver {
+
+int WasiNNRPCServer(int Argc, const char *Argv[]) noexcept;
+
+} // namespace Driver
+} // namespace WasmEdge
diff --git a/include/driver/wasi_nn_rpc/wasi_nn_rpcserver/wasi_nn_rpcserver.h b/include/driver/wasi_nn_rpc/wasi_nn_rpcserver/wasi_nn_rpcserver.h
new file mode 100644
index 00000000000..10cd68579b7
--- /dev/null
+++ b/include/driver/wasi_nn_rpc/wasi_nn_rpcserver/wasi_nn_rpcserver.h
@@ -0,0 +1,308 @@
+#pragma once
+
+#include "runtime/callingframe.h"
+#include "runtime/instance/module.h"
+#include "wasi_ephemeral_nn.grpc.pb.h"
+
+#include <grpc/grpc.h>
+#include <string_view>
+
+using namespace std::literals;
+using namespace WasmEdge;
+
+namespace WasmEdge {
+namespace WasiNNRPC {
+namespace Server {
+
+void writeUInt32WithBuilderPtr(
+    WasmEdge::Runtime::Instance::MemoryInstance &MemInst, uint32_t Value,
+    uint32_t &BuilderPtr) {
+  uint32_t *BufPtr = MemInst.getPointer<uint32_t *>(BuilderPtr);
+  *BufPtr = Value;
+  BuilderPtr += 4;
+}
+
+void writeFatPointerWithBuilderPtr(
+    WasmEdge::Runtime::Instance::MemoryInstance &MemInst, uint32_t PtrVal,
+    uint32_t PtrSize, uint32_t &BuilderPtr) {
+  writeUInt32WithBuilderPtr(MemInst, PtrVal, BuilderPtr);
+  writeUInt32WithBuilderPtr(MemInst, PtrSize, BuilderPtr);
+}
+
+template <typename T>
+void writeBinaries(WasmEdge::Runtime::Instance::MemoryInstance &MemInst,
+                   std::vector<T> Binaries, uint32_t Ptr) noexcept {
+  std::copy(Binaries.begin(), Binaries.end(), MemInst.getPointer<T *>(Ptr));
+}
+
+template <typename T>
+void writeBinaries(WasmEdge::Runtime::Instance::MemoryInstance &MemInst,
+                   google::protobuf::RepeatedField<T> Binaries,
+                   uint32_t Ptr) noexcept {
+  std::copy(Binaries.begin(), Binaries.end(), MemInst.getPointer<T *>(Ptr));
+}
+
+void writeBinaries(WasmEdge::Runtime::Instance::MemoryInstance &MemInst,
+                   const std::string &Binaries, uint32_t Ptr) noexcept {
+  std::copy(Binaries.begin(), Binaries.end(),
+            MemInst.getPointer<uint8_t *>(Ptr));
+}
+
+class HostFuncCaller {
+public:
+  HostFuncCaller(const Runtime::Instance::ModuleInstance &NNM,
+                 std::string_view FuncName, uint32_t MemorySize) noexcept
+      : FuncInst(NNM.findFuncExports(FuncName)), FuncName(FuncName), Mod(""),
+        Frame(nullptr, &Mod) {
+    Mod.addHostMemory(
+        "memory"sv,
+        std::make_unique<WasmEdge::Runtime::Instance::MemoryInstance>(
+            WasmEdge::AST::MemoryType(MemorySize)));
+  }
+
+  Runtime::Instance::MemoryInstance &getMemInst(void) {
+    return *Frame.getMemoryByIndex(0);
+  }
+
+  uint32_t call(std::initializer_list<WasmEdge::ValVariant> Args) {
+    if (FuncInst == nullptr) {
+      spdprintln(
+          "[WASI-NN-RPCSERVER] HostFuncCaller: FuncInst not found for {}"sv,
+          FuncName);
+      return 0xFFFFFFFF;
+    }
+    std::array<ValVariant, 1> Rets = {UINT32_C(0)};
+    if (!FuncInst->getHostFunc().run(Frame, Args, Rets)) {
+      spdprintln(
+          "[WASI-NN-RPCSERVER] HostFuncCaller: failed to run HostFunc for {}"sv,
+          FuncName);
+      return 0xFFFFFFFF;
+    }
+    uint32_t Errno = Rets[0].get<uint32_t>();
+    return Errno;
+  }
+
+private:
+  Runtime::Instance::FunctionInstance *FuncInst;
+  std::string_view FuncName;
+  Runtime::Instance::ModuleInstance Mod;
+  Runtime::CallingFrame Frame;
+};
+
+grpc::Status createRPCStatusFromErrno(std::string_view FuncName,
+                                      uint32_t Errno) {
+  // TODO: propagate Errno as gRPC metadata for machine-readability
+  return grpc::Status(
+      grpc::StatusCode::UNKNOWN,
+      fmt::format("failed to call host function \"{}\", errno={}"sv, FuncName,
+                  Errno));
+}
+
+class GraphService final : public wasi_ephemeral_nn::Graph::Service {
+public:
+  GraphService(const Runtime::Instance::ModuleInstance &NNM) noexcept
+      : NNMod(NNM) {}
+  /*
+    Expect<WASINN::ErrNo>
+    WasiNNLoadByName::bodyImpl(const Runtime::CallingFrame &Frame, uint32_t
+    NamePtr, uint32_t NameLen, uint32_t GraphIdPtr)
+  */
+  virtual grpc::Status
+  LoadByName(grpc::ServerContext * /*RPCContext*/,
+             const wasi_ephemeral_nn::LoadByNameRequest *RPCRequest,
+             wasi_ephemeral_nn::LoadByNameResult *RPCResult) {
+    std::string_view FuncName = "load_by_name"sv;
+    auto Name = RPCRequest->name();
+    uint32_t NamePtr = UINT32_C(0);
+    uint32_t NameLen = Name.size(); // does not include the '\0' terminator
+    uint32_t OutPtr = NamePtr + NameLen + 1; // 1 is for the '\0' terminator
+    uint32_t MemorySize = OutPtr + 4;        // 4 is for sizeof(OutPtr)
+
+    HostFuncCaller HostFuncCaller(NNMod, FuncName, MemorySize);
+    auto &MemInst = HostFuncCaller.getMemInst();
+    std::vector<char> NameVec(Name.begin(), Name.end());
+    writeBinaries(MemInst, NameVec, NamePtr);
+    uint32_t Errno = HostFuncCaller.call({NamePtr, NameLen, OutPtr});
+    if (Errno != 0) {
+      return createRPCStatusFromErrno(FuncName, Errno);
+    }
+    uint32_t GraphHandle = *MemInst.getPointer<uint32_t *>(OutPtr);
+    RPCResult->set_graph_handle(GraphHandle);
+    return grpc::Status::OK;
+  }
+
+private:
+  const Runtime::Instance::ModuleInstance &NNMod;
+};
+
+class GraphResourceService final
+    : public wasi_ephemeral_nn::GraphResource::Service {
+public:
+  GraphResourceService(const Runtime::Instance::ModuleInstance &NNM) noexcept
+      : NNMod(NNM) {}
+  /*
+    Expect<ErrNo> initExecCtx(WasiNNEnvironment &Env, uint32_t GraphId,
+                              uint32_t &ContextId) noexcept
+  */
+  virtual grpc::Status InitExecutionContext(
+      grpc::ServerContext * /*RPCContext*/,
+      const wasi_ephemeral_nn::InitExecutionContextRequest *RPCRequest,
+      wasi_ephemeral_nn::InitExecutionContextResult *RPCResult) {
+    std::string_view FuncName = "init_execution_context"sv;
+    uint32_t ResourceHandle = RPCRequest->resource_handle();
+    uint32_t OutPtr = UINT32_C(0);
+    uint32_t MemorySize = OutPtr + 4; // 4 is for sizeof(OutPtr)
+
+    HostFuncCaller HostFuncCaller(NNMod, FuncName, MemorySize);
+    auto &MemInst = HostFuncCaller.getMemInst();
+    uint32_t Errno = HostFuncCaller.call({ResourceHandle, OutPtr});
+    if (Errno != 0) {
+      return createRPCStatusFromErrno(FuncName, Errno);
+    }
+    uint32_t CtxHandle = *MemInst.getPointer<uint32_t *>(OutPtr);
+    RPCResult->set_ctx_handle(CtxHandle);
+    return grpc::Status::OK;
+  }
+
+private:
+  const Runtime::Instance::ModuleInstance &NNMod;
+};
+
+class GraphExecutionContextResourceService final
+    : public wasi_ephemeral_nn::GraphExecutionContextResource::Service {
+public:
+  GraphExecutionContextResourceService(
+      const Runtime::Instance::ModuleInstance &NNM) noexcept
+      : NNMod(NNM) {}
+
+  /*
+    Expect<ErrNo> setInput(WasiNNEnvironment &Env, uint32_t ContextId,
+                           uint32_t Index, const TensorData &Tensor) noexcept
+  */
+  virtual grpc::Status
+  SetInput(grpc::ServerContext * /*RPCContext*/,
+           const wasi_ephemeral_nn::SetInputRequest *RPCRequest,
+           google::protobuf::Empty * /*RPCResult*/) {
+    std::string_view FuncName = "set_input"sv;
+    uint32_t ResourceHandle = RPCRequest->resource_handle();
+    uint32_t Index = RPCRequest->index();
+    auto Tensor = RPCRequest->tensor();
+    auto TensorDim = Tensor.dimensions();
+    uint32_t TensorDimSize = TensorDim.size();
+    uint32_t TensorTy = Tensor.ty();
+    auto TensorData = Tensor.data();
+    uint32_t TensorDataSize = TensorData.size();
+
+    /* clang-format off */
+    /**
+       0                    : FatPointer (20, TensorDimSize)
+       8                    : TensorTy
+      12                    : FatPointer (20 + TensorDimSize * 4, TensorDataSize)
+      20                    : TensorDim
+      20 + TensorDimSize * 4: TensorData
+    */
+    /* clang-format on */
+    uint32_t BuilderPtr = UINT32_C(0);
+    uint32_t SetInputEntryPtr = BuilderPtr;
+    uint32_t TensorDimPtr = UINT32_C(20);
+    uint32_t TensorDataPtr = TensorDimPtr + TensorDimSize * 4;
+    uint32_t MemorySize = TensorDataPtr + TensorDataSize;
+
+    HostFuncCaller HostFuncCaller(NNMod, FuncName, MemorySize);
+    auto &MemInst = HostFuncCaller.getMemInst();
+    writeFatPointerWithBuilderPtr(MemInst, TensorDimPtr, TensorDimSize,
+                                  BuilderPtr);
+    writeUInt32WithBuilderPtr(MemInst, TensorTy, BuilderPtr);
+    writeFatPointerWithBuilderPtr(MemInst, TensorDataPtr, TensorDataSize,
+                                  BuilderPtr);
+    writeBinaries<uint32_t>(MemInst, TensorDim, TensorDimPtr);
+    writeBinaries(MemInst, TensorData, TensorDataPtr);
+
+    uint32_t Errno =
+        HostFuncCaller.call({ResourceHandle, Index, SetInputEntryPtr});
+    if (Errno != 0) {
+      return createRPCStatusFromErrno(FuncName, Errno);
+    }
+    return grpc::Status::OK;
+  }
+
+  /*
+    Expect<ErrNo> compute(WasiNNEnvironment &Env, uint32_t ContextId) noexcept
+  */
+  virtual grpc::Status
+  Compute(grpc::ServerContext * /*RPCContext*/,
+          const wasi_ephemeral_nn::ComputeRequest *RPCRequest,
+          google::protobuf::Empty * /*RPCResult*/) {
+    std::string_view FuncName = "compute"sv;
+    uint32_t ResourceHandle = RPCRequest->resource_handle();
+    uint32_t MemorySize = UINT32_C(0);
+    HostFuncCaller HostFuncCaller(NNMod, FuncName, MemorySize);
+    uint32_t Errno = HostFuncCaller.call({ResourceHandle});
+    if (Errno != 0) {
+      return createRPCStatusFromErrno(FuncName, Errno);
+    }
+    return grpc::Status::OK;
+  }
+
+  /*
+    Expect<ErrNo> getOutput(WasiNNEnvironment &Env, uint32_t ContextId,
+                            uint32_t Index, Span<uint8_t> OutBuffer,
+                            uint32_t &BytesWritten) noexcept
+  */
+  virtual grpc::Status
+  GetOutput(grpc::ServerContext * /*RPCContext*/,
+            const wasi_ephemeral_nn::GetOutputRequest *RPCRequest,
+            wasi_ephemeral_nn::GetOutputResult *RPCResult) {
+    std::string_view FuncName = "get_output"sv;
+    uint32_t ResourceHandle = RPCRequest->resource_handle();
+    uint32_t Index = RPCRequest->index();
+    uint32_t MemorySize = UINT32_C(65536); // FIXME
+    uint32_t BytesWrittenPtr = UINT32_C(0);
+    uint32_t BufPtr = BytesWrittenPtr + UINT32_C(4);
+    uint32_t BufMaxSize = MemorySize - BufPtr;
+    HostFuncCaller HostFuncCaller(NNMod, FuncName, MemorySize);
+    auto &MemInst = HostFuncCaller.getMemInst();
+    uint32_t Errno = HostFuncCaller.call(
+        {ResourceHandle, Index, BufPtr, BufMaxSize, BytesWrittenPtr});
+    if (Errno != 0) {
+      return createRPCStatusFromErrno(FuncName, Errno);
+    }
+    /* clang-format off */
+    /**
+       0                    : BytesWritten
+       4                    : Buf
+    */
+    /* clang-format on */
+    auto BytesWritten = *MemInst.getPointer<uint32_t *>(BytesWrittenPtr);
+    auto *Buf = MemInst.getPointer<char *>(BufPtr);
+    RPCResult->set_data(Buf, BytesWritten);
+    return grpc::Status::OK;
+  }
+
+private:
+  const Runtime::Instance::ModuleInstance &NNMod;
+};
+
+class ServiceSet {
+public:
+  ServiceSet(const Runtime::Instance::ModuleInstance &NNM) noexcept
+      : Graph(GraphService(NNM)), GraphResource(GraphResourceService(NNM)),
+        GraphExecutionContextResource(
+            GraphExecutionContextResourceService(NNM)) {}
+
+  std::vector<grpc::Service *> services(void) {
+    return std::vector<grpc::Service *>{
+        &Graph,
+        &GraphResource,
+        &GraphExecutionContextResource,
+    };
+  }
+
+private:
+  GraphService Graph;
+  GraphResourceService GraphResource;
+  GraphExecutionContextResourceService GraphExecutionContextResource;
+};
+} // namespace Server
+} // namespace WasiNNRPC
+} // namespace WasmEdge
diff --git a/lib/CMakeLists.txt b/lib/CMakeLists.txt
index cc606d3adc6..a7f09e1c6ad 100644
--- a/lib/CMakeLists.txt
+++ b/lib/CMakeLists.txt
@@ -17,3 +17,6 @@ add_subdirectory(driver)
 if(WASMEDGE_BUILD_SHARED_LIB OR WASMEDGE_BUILD_STATIC_LIB OR WASMEDGE_BUILD_TOOLS)
   add_subdirectory(api)
 endif()
+if(WASMEDGE_BUILD_WASI_NN_RPC)
+  add_subdirectory(wasi_nn_rpc)
+endif()
diff --git a/lib/api/CMakeLists.txt b/lib/api/CMakeLists.txt
index 7f0ff8c2fd0..5e8e46e11a2 100644
--- a/lib/api/CMakeLists.txt
+++ b/lib/api/CMakeLists.txt
@@ -6,6 +6,9 @@ add_definitions(-DWASMEDGE_COMPILE_LIBRARY)
 if(WASMEDGE_BUILD_AOT_RUNTIME)
   add_definitions(-DWASMEDGE_BUILD_AOT_RUNTIME)
 endif()
+if(WASMEDGE_BUILD_WASI_NN_RPC)
+  add_definitions(-DWASMEDGE_BUILD_WASI_NN_RPC)
+endif()
 
 get_filename_component(CMAKE_AR_NAME "${CMAKE_AR}" NAME)
 
diff --git a/lib/api/wasmedge.cpp b/lib/api/wasmedge.cpp
index d2c873735cf..4fce4d66fed 100644
--- a/lib/api/wasmedge.cpp
+++ b/lib/api/wasmedge.cpp
@@ -18,6 +18,10 @@
 #include "driver/fuzzTool.h"
 #endif
 
+#ifdef WASMEDGE_BUILD_WASI_NN_RPC
+#include "driver/wasiNNRPCServerTool.h"
+#endif
+
 #include <algorithm>
 #include <chrono>
 #include <cstdint>
@@ -3134,6 +3138,15 @@ WASMEDGE_CAPI_EXPORT int WasmEdge_Driver_Tool(int Argc, const char *Argv[]) {
                                    WasmEdge::Driver::ToolType::Tool);
 }
 
+#ifdef WASMEDGE_BUILD_WASI_NN_RPC
+WASMEDGE_CAPI_EXPORT int WasmEdge_Driver_WasiNNRPCServer(int Argc,
+                                                         const char *Argv[]) {
+  // UniTool does not support ToolType::WasiNNRPCServer yet (to avoid #ifdef
+  // hell)
+  return WasmEdge::Driver::WasiNNRPCServer(Argc, Argv);
+}
+#endif
+
 WASMEDGE_CAPI_EXPORT int WasmEdge_Driver_UniTool(int Argc, const char *Argv[]) {
   return WasmEdge::Driver::UniTool(Argc, Argv, WasmEdge::Driver::ToolType::All);
 }
diff --git a/lib/driver/CMakeLists.txt b/lib/driver/CMakeLists.txt
index 72b802f5497..127366a67e3 100644
--- a/lib/driver/CMakeLists.txt
+++ b/lib/driver/CMakeLists.txt
@@ -1,7 +1,7 @@
 # SPDX-License-Identifier: Apache-2.0
 # SPDX-FileCopyrightText: 2019-2022 Second State INC
 
-wasmedge_add_library(wasmedgeDriver
+set(SOURCES
   compilerTool.cpp
   runtimeTool.cpp
   fuzzTool.cpp
@@ -9,6 +9,21 @@ wasmedge_add_library(wasmedgeDriver
   uniTool.cpp
 )
 
+if(WASMEDGE_BUILD_WASI_NN_RPC)
+  list(APPEND SOURCES wasiNNRPCServerTool.cpp)
+endif()
+
+wasmedge_add_library(wasmedgeDriver
+  ${SOURCES}
+)
+
+if(WASMEDGE_BUILD_WASI_NN_RPC)
+  target_link_libraries(wasmedgeDriver
+    PRIVATE
+    wasiNNRPC
+  )
+endif()
+
 if(WASMEDGE_BUILD_AOT_RUNTIME)
   target_link_libraries(wasmedgeDriver
     PRIVATE
diff --git a/lib/driver/wasiNNRPCServerTool.cpp b/lib/driver/wasiNNRPCServerTool.cpp
new file mode 100644
index 00000000000..a760f06d967
--- /dev/null
+++ b/lib/driver/wasiNNRPCServerTool.cpp
@@ -0,0 +1,97 @@
+#include "common/log.h"
+#include "driver/wasi_nn_rpc/wasi_nn_rpcserver/wasi_nn_rpcserver.h"
+#include "plugin/plugin.h"
+#include "po/argument_parser.h"
+
+#include <grpcpp/server_builder.h>
+#include <string_view>
+
+using namespace std::literals;
+using namespace WasmEdge;
+
+namespace WasmEdge {
+namespace Driver {
+
+void loadPlugins(void) {
+  for (const auto &Path : Plugin::Plugin::getDefaultPluginPaths()) {
+    spdprintln("Loading plugin path {}"sv, Path);
+    if (Plugin::Plugin::load(Path)) {
+      spdprintln("Loaded plugin path {}"sv, Path);
+    } else {
+      spdprintln("Nothing was loaded from plugin path {}"sv, Path);
+    }
+  }
+  for (const auto &Plugin : Plugin::Plugin::plugins()) {
+    spdprintln("Plugin: {}", Plugin.name());
+  }
+}
+
+Runtime::Instance::ModuleInstance *createWasiNNModule() {
+  if (const auto *Plugin = Plugin::Plugin::find("wasi_nn"sv)) {
+    if (const auto *Module = Plugin->findModule("wasi_nn"sv)) {
+      return Module->create().release();
+    }
+  }
+  return nullptr;
+}
+
+int WasiNNRPCServer(int Argc, const char *Argv[]) noexcept {
+  std::ios::sync_with_stdio(false);
+  Log::setInfoLoggingLevel();
+  setenv("_WASI_NN_RPCSERVER", "1", 1); // wasi_nn plugin checks this env var
+
+  // Parse the args
+  PO::Option<std::string> NNRPCURI(
+      PO::Description("Specify NN RPC URI to serve (\"unix://...\")"sv),
+      PO::MetaVar("URI"sv), PO::DefaultValue(std::string("")));
+  auto Parser = PO::ArgumentParser();
+  Parser.add_option("nn-rpc-uri"sv, NNRPCURI);
+  loadPlugins();
+  Plugin::Plugin::addPluginOptions(Parser); // Register "nn-preload", etc.
+  if (!Parser.parse(stdout, Argc, Argv)) {
+    return EXIT_FAILURE;
+  }
+  if (Parser.isHelp()) {
+    return EXIT_SUCCESS;
+  }
+  auto URI = NNRPCURI.value();
+  if (URI.empty()) {
+    spdprintln("--nn-rpc-uri has to be specified"sv);
+    return EXIT_FAILURE;
+  }
+
+  // Create the wasi_nn module
+  auto *NNMod = createWasiNNModule();
+  if (NNMod == nullptr) {
+    spdprintln(
+        "Failed to get the wasi_nn module (Hint: set $WASMEDGE_PLUGIN_PATH to "
+        "the directory where libwasmedgePluginWasiNN.* exists"sv);
+    return EXIT_FAILURE;
+  }
+
+  // Create the services
+  WasiNNRPC::Server::ServiceSet ServiceSet(*NNMod);
+
+  // Create the gRPC server
+  grpc::ServerBuilder Builder;
+  spdprintln("Listening on \"{}\""sv, URI);
+  std::string_view UnixPrefix = "unix://";
+  if (URI.substr(0, UnixPrefix.length()) != UnixPrefix) {
+    spdlog::warn("Expected \"unix://...\", got \"{}\""sv, URI);
+  }
+  auto Cred = grpc::InsecureServerCredentials(); // safe for unix://...
+  Builder.AddListeningPort(URI, Cred);
+  for (auto *Service : ServiceSet.services()) {
+    Builder.RegisterService(Service);
+  }
+
+  // Start the gRPC server
+  auto Server = Builder.BuildAndStart();
+  if (Server == nullptr) {
+    return EXIT_FAILURE;
+  }
+  Server->Wait();
+  return EXIT_SUCCESS;
+}
+} // namespace Driver
+} // namespace WasmEdge
diff --git a/lib/wasi_nn_rpc/CMakeLists.txt b/lib/wasi_nn_rpc/CMakeLists.txt
new file mode 100644
index 00000000000..2807b645303
--- /dev/null
+++ b/lib/wasi_nn_rpc/CMakeLists.txt
@@ -0,0 +1,47 @@
+find_package(PkgConfig REQUIRED)
+pkg_check_modules(PROTOBUF protobuf REQUIRED)
+pkg_check_modules(GRPC grpc REQUIRED)
+pkg_check_modules(GRPCPP grpc++ REQUIRED)
+
+# gRPC::grpc_cpp_plugin can't be used because libgrpc-dev for Ubuntu 22.04 does not contain cmake files.
+# https://packages.ubuntu.com/search?keywords=libgrpc-dev
+find_program(GRPC_CPP_PLUGIN grpc_cpp_plugin REQUIRED)
+
+# protobuf_generate() can't be used on Debian, Ubuntu, etc., as libprotobuf-dev does not contain cmake files:
+# https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=1027876
+# The situation is similar for other distros too.
+# As a workaround, we execute the protoc command directly.
+execute_process(
+  COMMAND protoc --proto_path=${CMAKE_CURRENT_SOURCE_DIR} --cpp_out=${CMAKE_CURRENT_BINARY_DIR} ${CMAKE_CURRENT_SOURCE_DIR}/wasi_ephemeral_nn.proto
+  COMMAND protoc --proto_path=${CMAKE_CURRENT_SOURCE_DIR} --grpc_out=${CMAKE_CURRENT_BINARY_DIR} --plugin=protoc-gen-grpc=${GRPC_CPP_PLUGIN} ${CMAKE_CURRENT_SOURCE_DIR}/wasi_ephemeral_nn.proto
+)
+
+# wasiNNRPC has to be a separate shared library to avoid
+# `[libprotobuf ERROR google/protobuf/descriptor_database.cc:120] File already exists in database: wasi_ephemeral_nn.proto`,
+# because both wasi_nn_rpcserver and libwasmedgePluginWasiNN.so depend on it.
+# https://github.com/protocolbuffers/protobuf/issues/1941#issuecomment-284582895
+if(NOT WASMEDGE_BUILD_SHARED_LIB)
+  message(FATAL_ERROR "WASMEDGE_BUILD_WASI_NN_RPC depends on WASMEDGE_BUILD_SHARED_LIB")
+endif()
+wasmedge_add_library(wasiNNRPC SHARED
+  wasi_ephemeral_nn.grpc.pb.cc
+  wasi_ephemeral_nn.grpc.pb.h
+  wasi_ephemeral_nn.pb.cc
+  wasi_ephemeral_nn.pb.h
+)
+set_target_properties(wasiNNRPC PROPERTIES
+  CXX_VISIBILITY_PRESET default
+  VERSION "${WASMEDGE_WASI_NN_VERSION}"
+  SOVERSION "${WASMEDGE_WASI_NN_SOVERSION}"
+)
+install(TARGETS wasiNNRPC
+  LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
+)
+
+target_include_directories(wasiNNRPC PUBLIC ${CMAKE_CURRENT_BINARY_DIR})
+target_compile_options(wasiNNRPC PUBLIC ${PROTOBUF_CFLAGS})
+target_compile_options(wasiNNRPC PUBLIC ${GRPCPP_CFLAGS})
+target_link_libraries(wasiNNRPC PUBLIC ${PROTOBUF_LDFLAGS})
+target_link_libraries(wasiNNRPC PUBLIC ${GRPCPP_LDFLAGS})
+# grpc++_reflection helps debugging the server with grpcurl
+# target_link_libraries(wasiNNRPC PUBLIC grpc++_reflection)
diff --git a/lib/wasi_nn_rpc/wasi_ephemeral_nn.proto b/lib/wasi_nn_rpc/wasi_ephemeral_nn.proto
new file mode 100644
index 00000000000..3ed030e455d
--- /dev/null
+++ b/lib/wasi_nn_rpc/wasi_ephemeral_nn.proto
@@ -0,0 +1,81 @@
+syntax = "proto3";
+
+import "google/protobuf/empty.proto";
+
+// The services are expected to be exposed to another host via a UNIX socket with ssh forwarding
+// (`ssh -R remote.sock:local.sock`).
+// Must not be exposed to an untrusted host.
+
+package wasi_ephemeral_nn;
+
+enum TensorType {
+  FP16 = 0;
+  FP32 = 1;
+  FP64 = 2;
+  BF16 = 3;
+  U8 = 4;
+  I32 = 5;
+  I64 = 6;
+}
+
+message Tensor {
+  repeated uint32 dimensions = 1 [packed=true];
+  TensorType ty = 2;
+  bytes data = 3;
+}
+
+message InitExecutionContextRequest {
+  uint32 resource_handle = 1;
+}
+
+message InitExecutionContextResult {
+  uint32 ctx_handle = 1;
+}
+
+service GraphResource {
+  rpc InitExecutionContext(InitExecutionContextRequest) returns (InitExecutionContextResult) {};
+}
+
+message LoadByNameRequest {
+  string name = 1;
+}
+
+message LoadByNameResult {
+  uint32 graph_handle = 1;
+}
+
+service Graph {
+  // No support for Load yet
+  rpc LoadByName(LoadByNameRequest) returns (LoadByNameResult) {};
+}
+
+message SetInputRequest {
+  uint32 resource_handle = 1;
+  uint32 index = 2; // defined as a string in wit
+  Tensor tensor = 3;
+}
+
+message ComputeRequest{
+  uint32 resource_handle = 1;
+}
+
+message GetOutputRequest {
+  uint32 resource_handle = 1;
+  uint32 index = 2; // defined as a string in wit
+}
+
+message GetOutputResult {
+  bytes data = 1; // defined as a tensor in wit
+}
+
+service GraphExecutionContextResource {
+  rpc SetInput(SetInputRequest) returns (google.protobuf.Empty) {};
+  rpc Compute(ComputeRequest) returns (google.protobuf.Empty) {};
+  rpc GetOutput(GetOutputRequest) returns (GetOutputResult) {};
+}
+
+// ref:
+// - https://github.com/WebAssembly/wasi-nn/blob/06c30c0e12e39e674b6503614352dcf6dc0c96e0/wasi-nn.witx
+// - https://github.com/second-state/wasmedge-wasi-nn/blob/d6124116bc106ea2a453c72ca4222d8917b66820/assemblyscript/assembly/wasi_ephemeral_nn.ts
+// - https://github.com/second-state/wasmedge-wasi-nn/blob/d6124116bc106ea2a453c72ca4222d8917b66820/rust/src/generated.rs#L303-L313
+// - https://github.com/WebAssembly/wasi-nn/blob/06c30c0e12e39e674b6503614352dcf6dc0c96e0/wit/wasi-nn.wit (WasmEdge implementation currently follows witx, not wit)
diff --git a/plugins/wasi_nn/CMakeLists.txt b/plugins/wasi_nn/CMakeLists.txt
index a09c7bb7107..9411b092edb 100644
--- a/plugins/wasi_nn/CMakeLists.txt
+++ b/plugins/wasi_nn/CMakeLists.txt
@@ -131,6 +131,9 @@ target_compile_options(wasmedgePluginWasiNN
   PUBLIC
   -DWASMEDGE_PLUGIN
 )
+if(WASMEDGE_BUILD_WASI_NN_RPC)
+  add_definitions(-DWASMEDGE_BUILD_WASI_NN_RPC)
+endif()
 
 target_include_directories(wasmedgePluginWasiNN
   PUBLIC
@@ -162,6 +165,16 @@ else()
   )
 endif()
 
+if(WASMEDGE_BUILD_WASI_NN_RPC)
+  target_include_directories(wasmedgePluginWasiNN
+    SYSTEM BEFORE PUBLIC ${Protobuf_INCLUDE_DIR}
+  )
+  target_link_libraries(wasmedgePluginWasiNN
+    PRIVATE
+    wasiNNRPC
+  )
+endif()
+
 include(WASINNDeps)
 wasmedge_setup_wasinn_target(wasmedgePluginWasiNN)
 
diff --git a/plugins/wasi_nn/wasinnenv.cpp b/plugins/wasi_nn/wasinnenv.cpp
index 6c90ae54b12..438c7f02455 100644
--- a/plugins/wasi_nn/wasinnenv.cpp
+++ b/plugins/wasi_nn/wasinnenv.cpp
@@ -6,6 +6,10 @@
 
 #include <sstream>
 
+#ifdef WASMEDGE_BUILD_WASI_NN_RPC
+#include <grpc/grpc.h>
+#endif
+
 namespace WasmEdge {
 namespace Host {
 
@@ -46,6 +50,25 @@ bool load(const std::filesystem::path &Path, std::vector<uint8_t> &Data) {
 }
 
 WasiNNEnvironment::WasiNNEnvironment() noexcept {
+#ifdef WASMEDGE_BUILD_WASI_NN_RPC
+  if (getenv("_WASI_NN_RPCSERVER") == nullptr) {
+    // RPC client mode
+    auto URI = NNRPCURI.value();
+    if (!URI.empty()) {
+      std::string_view UnixPrefix = "unix://";
+      if (URI.substr(0, UnixPrefix.length()) != UnixPrefix) {
+        spdlog::warn("[WASI-NN] Expected \"unix://...\", got \"{}\""sv, URI);
+      }
+      auto Cred = grpc::InsecureChannelCredentials(); // safe for unix://...
+      NNRPCChannel = grpc::CreateChannel(URI, Cred);
+      if (NNModels.value().size() > 0) {
+        spdlog::warn(
+            "[WASI-NN] nn-preload has to be specified on the RPC server side, not on the client side"sv);
+      }
+      return;
+    }
+  }
+#endif
   // Preload NN Models
   for (const auto &M : NNModels.value()) {
     std::istringstream ISS(M);
@@ -100,9 +123,21 @@ PO::List<std::string> WasiNNEnvironment::NNModels(
         "Allow preload models from wasinn plugin. Each NN model can be specified as --nn-preload `COMMAND`."sv),
     PO::MetaVar("COMMANDS"sv));
 
+#ifdef WASMEDGE_BUILD_WASI_NN_RPC
+PO::Option<std::string> WasiNNEnvironment::NNRPCURI(
+    PO::Description("Specify NN RPC URI to connect (\"unix://...\")"sv),
+    PO::MetaVar("URI"sv), PO::DefaultValue(std::string("")));
+#endif
+
 void addOptions(const Plugin::Plugin::PluginDescriptor *,
                 PO::ArgumentParser &Parser) noexcept {
   Parser.add_option("nn-preload"sv, WasiNNEnvironment::NNModels);
+#ifdef WASMEDGE_BUILD_WASI_NN_RPC
+  if (getenv("_WASI_NN_RPCSERVER") == nullptr) {
+    // RPC client mode
+    Parser.add_option("nn-rpc-uri"sv, WasiNNEnvironment::NNRPCURI);
+  }
+#endif
 }
 
 Plugin::Plugin::PluginDescriptor Descriptor{
diff --git a/plugins/wasi_nn/wasinnenv.h b/plugins/wasi_nn/wasinnenv.h
index 7d919b5cc65..00c8df0fb0d 100644
--- a/plugins/wasi_nn/wasinnenv.h
+++ b/plugins/wasi_nn/wasinnenv.h
@@ -17,6 +17,11 @@
 #include "torch.h"
 #include "types.h"
 
+#ifdef WASMEDGE_BUILD_WASI_NN_RPC
+#include <grpc/grpc.h>
+#include <grpcpp/create_channel.h>
+#endif
+
 namespace WasmEdge {
 namespace Host {
 namespace WASINN {
@@ -197,7 +202,10 @@ struct WasiNNEnvironment :
   std::vector<Graph> NNGraph;
   std::vector<Context> NNContext;
   static PO::List<std::string> NNModels;
-
+#ifdef WASMEDGE_BUILD_WASI_NN_RPC
+  static PO::Option<std::string> NNRPCURI; // For RPC client mode
+  std::shared_ptr<grpc::Channel> NNRPCChannel;
+#endif
   static Plugin::PluginRegister Register;
 };
 
diff --git a/plugins/wasi_nn/wasinnfunc.cpp b/plugins/wasi_nn/wasinnfunc.cpp
index 3be2bca821d..6ccf2b45912 100644
--- a/plugins/wasi_nn/wasinnfunc.cpp
+++ b/plugins/wasi_nn/wasinnfunc.cpp
@@ -8,6 +8,12 @@
 #include <string>
 #include <string_view>
 
+#ifdef WASMEDGE_BUILD_WASI_NN_RPC
+#include "wasi_ephemeral_nn.grpc.pb.h"
+
+#include <grpc/grpc.h>
+#endif // #ifdef WASMEDGE_BUILD_WASI_NN_RPC
+
 namespace WasmEdge {
 namespace Host {
 
@@ -36,6 +42,13 @@ Expect<WASINN::ErrNo>
 WasiNNLoad::bodyImpl(const Runtime::CallingFrame &Frame, uint32_t BuilderPtr,
                      uint32_t BuilderLen, uint32_t RawEncoding, uint32_t Target,
                      uint32_t GraphIdPtr) {
+#ifdef WASMEDGE_BUILD_WASI_NN_RPC
+  if (Env.NNRPCChannel != nullptr) {
+    // TODO: implement RPC for Load
+    spdprintln("[WASI-NN] RPC client is not implemented for Load"sv);
+    return WASINN::ErrNo::UnsupportedOperation;
+  }
+#endif
   // Check memory instance from module.
   auto *MemInst = Frame.getMemoryByIndex(0);
   if (MemInst == nullptr) {
@@ -113,6 +126,25 @@ WasiNNLoadByName::bodyImpl(const Runtime::CallingFrame &Frame, uint32_t NamePtr,
     return WASINN::ErrNo::InvalidArgument;
   }
 
+#ifdef WASMEDGE_BUILD_WASI_NN_RPC
+  if (Env.NNRPCChannel != nullptr) {
+    auto Stub = wasi_ephemeral_nn::Graph::NewStub(Env.NNRPCChannel);
+    grpc::ClientContext ClientContext;
+    wasi_ephemeral_nn::LoadByNameRequest Req;
+    auto NameStrView = MemInst->getStringView(NamePtr, NameLen);
+    Req.set_name(NameStrView.data(), NameStrView.size());
+    wasi_ephemeral_nn::LoadByNameResult Res;
+    auto Status = Stub->LoadByName(&ClientContext, Req, &Res);
+    if (!Status.ok()) {
+      spdprintln("[WASI-NN] Failed when calling remote LoadByName: {}"sv,
+                    Status.error_message());
+      return WASINN::ErrNo::RuntimeError;
+    }
+    *GraphId = Res.graph_handle();
+    return WASINN::ErrNo::Success;
+  }
+#endif // ifdef WASMEDGE_BUILD_WASI_NN_RPC
+
   // Get the model
   std::string ModelName(reinterpret_cast<const char *>(Name), NameLen);
   if (Env.mdGet(ModelName, *GraphId)) {
@@ -125,6 +157,14 @@ WasiNNLoadByName::bodyImpl(const Runtime::CallingFrame &Frame, uint32_t NamePtr,
 Expect<WASINN::ErrNo> WasiNNLoadByNameWithConfig::bodyImpl(
     const Runtime::CallingFrame &Frame, uint32_t NamePtr, uint32_t NameLen,
     uint32_t ConfigPtr, uint32_t ConfigLen, uint32_t GraphIdPtr) {
+#ifdef WASMEDGE_BUILD_WASI_NN_RPC
+  if (Env.NNRPCChannel != nullptr) {
+    // TODO: implement RPC for LoadByNameWithConfig
+    spdprintln(
+        "[WASI-NN] RPC client is not implemented for LoadByNameWithConfig"sv);
+    return WASINN::ErrNo::UnsupportedOperation;
+  }
+#endif
   auto *MemInst = Frame.getMemoryByIndex(0);
   if (MemInst == nullptr) {
     return Unexpect(ErrCode::Value::HostFuncError);
@@ -172,12 +212,6 @@ WasiNNInitExecCtx::bodyImpl(const Runtime::CallingFrame &Frame,
     return Unexpect(ErrCode::Value::HostFuncError);
   }
 
-  if (Env.NNGraph.size() <= GraphId) {
-    spdprintln(
-        "[WASI-NN] init_execution_context: Graph Id does not exist."sv);
-    return WASINN::ErrNo::InvalidArgument;
-  }
-
   // Check the return value: Context should be valid.
   uint32_t *Context = MemInst->getPointer<uint32_t *>(ContextPtr);
   if (unlikely(Context == nullptr)) {
@@ -185,6 +219,31 @@ WasiNNInitExecCtx::bodyImpl(const Runtime::CallingFrame &Frame,
     return WASINN::ErrNo::InvalidArgument;
   }
 
+#ifdef WASMEDGE_BUILD_WASI_NN_RPC
+  if (Env.NNRPCChannel != nullptr) {
+    auto Stub = wasi_ephemeral_nn::GraphResource::NewStub(Env.NNRPCChannel);
+    grpc::ClientContext ClientContext;
+    wasi_ephemeral_nn::InitExecutionContextRequest Req;
+    Req.set_resource_handle(GraphId);
+    wasi_ephemeral_nn::InitExecutionContextResult Res;
+    auto Status = Stub->InitExecutionContext(&ClientContext, Req, &Res);
+    if (!Status.ok()) {
+      spdprintln(
+          "[WASI-NN] Failed when calling remote InitExecutionContext: {}"sv,
+          Status.error_message());
+      return WASINN::ErrNo::RuntimeError;
+    }
+    *Context = Res.ctx_handle();
+    return WASINN::ErrNo::Success;
+  }
+#endif // ifdef WASMEDGE_BUILD_WASI_NN_RPC
+
+  if (Env.NNGraph.size() <= GraphId) {
+    spdprintln(
+        "[WASI-NN] init_execution_context: Graph Id does not exist."sv);
+    return WASINN::ErrNo::InvalidArgument;
+  }
+
   switch (const auto Backend = Env.NNGraph[GraphId].getBackend()) {
 #define EACH(B)                                                                \
   case WASINN::Backend::B:                                                     \
@@ -205,11 +264,6 @@ WasiNNSetInput::bodyImpl(const Runtime::CallingFrame &Frame, uint32_t Context,
     return Unexpect(ErrCode::Value::HostFuncError);
   }
 
-  if (Env.NNContext.size() <= Context) {
-    spdprintln("[WASI-NN] set_input: Execution Context does not exist."sv);
-    return WASINN::ErrNo::InvalidArgument;
-  }
-
   // Tensor's Layout:
   //   | dim buf | dim buf len | rtype | data buf | data buf len |
   struct WasiTensorData {
@@ -225,6 +279,7 @@ WasiNNSetInput::bodyImpl(const Runtime::CallingFrame &Frame, uint32_t Context,
     spdprintln("[WASI-NN] Failed when accessing the Tensor memory."sv);
     return WASINN::ErrNo::InvalidArgument;
   }
+
   WASINN::TensorData Tensor;
   Tensor.Dimension = MemInst->getSpan<uint32_t>(WasiTensor->DimensionPtr,
                                                 WasiTensor->DimensionLen);
@@ -252,6 +307,37 @@ WasiNNSetInput::bodyImpl(const Runtime::CallingFrame &Frame, uint32_t Context,
     return WASINN::ErrNo::InvalidArgument;
   }
 
+#ifdef WASMEDGE_BUILD_WASI_NN_RPC
+  if (Env.NNRPCChannel != nullptr) {
+    auto Stub = wasi_ephemeral_nn::GraphExecutionContextResource::NewStub(
+        Env.NNRPCChannel);
+    grpc::ClientContext ClientContext;
+    wasi_ephemeral_nn::SetInputRequest Req;
+    Req.set_resource_handle(Context);
+    Req.set_index(Index);
+    wasi_ephemeral_nn::Tensor RPCTensor;
+    RPCTensor.mutable_dimensions()->Add(Tensor.Dimension.begin(),
+                                        Tensor.Dimension.end());
+    RPCTensor.set_ty(wasi_ephemeral_nn::TensorType(Tensor.RType));
+    RPCTensor.set_data(MemInst->getPointer<char *>(WasiTensor->TensorPtr),
+                       WasiTensor->TensorLen);
+    *Req.mutable_tensor() = RPCTensor;
+    google::protobuf::Empty Res;
+    auto Status = Stub->SetInput(&ClientContext, Req, &Res);
+    if (!Status.ok()) {
+      spdprintln("[WASI-NN] Failed when calling remote SetInput: {}"sv,
+                    Status.error_message());
+      return WASINN::ErrNo::RuntimeError;
+    }
+    return WASINN::ErrNo::Success;
+  }
+#endif // ifdef WASMEDGE_BUILD_WASI_NN_RPC
+
+  if (Env.NNContext.size() <= Context) {
+    spdprintln("[WASI-NN] set_input: Execution Context does not exist."sv);
+    return WASINN::ErrNo::InvalidArgument;
+  }
+
   switch (const auto Backend = Env.NNContext[Context].getBackend()) {
 #define EACH(B)                                                                \
   case WASINN::Backend::B:                                                     \
@@ -273,11 +359,6 @@ WasiNNGetOutput::bodyImpl(const Runtime::CallingFrame &Frame, uint32_t Context,
     return Unexpect(ErrCode::Value::HostFuncError);
   }
 
-  if (Env.NNContext.size() <= Context) {
-    spdprintln("[WASI-NN] get_output: Execution Context does not exist"sv);
-    return WASINN::ErrNo::InvalidArgument;
-  }
-
   const auto OutBuffer =
       MemInst->getSpan<uint8_t>(OutBufferPtr, OutBufferMaxSize);
   if (unlikely(OutBuffer.data() == nullptr)) {
@@ -291,6 +372,34 @@ WasiNNGetOutput::bodyImpl(const Runtime::CallingFrame &Frame, uint32_t Context,
     return WASINN::ErrNo::InvalidArgument;
   }
 
+#ifdef WASMEDGE_BUILD_WASI_NN_RPC
+  if (Env.NNRPCChannel != nullptr) {
+    auto Stub = wasi_ephemeral_nn::GraphExecutionContextResource::NewStub(
+        Env.NNRPCChannel);
+    grpc::ClientContext ClientContext;
+    wasi_ephemeral_nn::GetOutputRequest Req;
+    Req.set_resource_handle(Context);
+    Req.set_index(Index);
+    wasi_ephemeral_nn::GetOutputResult Res;
+    auto Status = Stub->GetOutput(&ClientContext, Req, &Res);
+    if (!Status.ok()) {
+      spdprintln("[WASI-NN] Failed when calling remote GetOutput: {}"sv,
+                    Status.error_message());
+      return WASINN::ErrNo::RuntimeError;
+    }
+    uint32_t BytesWrittenVal =
+        std::min(static_cast<uint32_t>(Res.data().size()), OutBufferMaxSize);
+    std::copy_n(Res.data().begin(), BytesWrittenVal, OutBuffer.begin());
+    *BytesWritten = BytesWrittenVal;
+    return WASINN::ErrNo::Success;
+  }
+#endif // ifdef WASMEDGE_BUILD_WASI_NN_RPC
+
+  if (Env.NNContext.size() <= Context) {
+    spdprintln("[WASI-NN] get_output: Execution Context does not exist"sv);
+    return WASINN::ErrNo::InvalidArgument;
+  }
+
   switch (const auto Backend = Env.NNContext[Context].getBackend()) {
 #define EACH(B)                                                                \
   case WASINN::Backend::B:                                                     \
@@ -307,6 +416,14 @@ Expect<WASINN::ErrNo> WasiNNGetOutputSingle::bodyImpl(
     const Runtime::CallingFrame &Frame, uint32_t Context, uint32_t Index,
     uint32_t OutBufferPtr, uint32_t OutBufferMaxSize,
     uint32_t BytesWrittenPtr) {
+#ifdef WASMEDGE_BUILD_WASI_NN_RPC
+  if (Env.NNRPCChannel != nullptr) {
+    // TODO: implement RPC for GetOutputSingle
+    spdprintln(
+        "[WASI-NN] RPC client is not implemented for GetOutputSingle"sv);
+    return WASINN::ErrNo::UnsupportedOperation;
+  }
+#endif
   auto *MemInst = Frame.getMemoryByIndex(0);
   if (MemInst == nullptr) {
     return Unexpect(ErrCode::Value::HostFuncError);
@@ -344,6 +461,23 @@ Expect<WASINN::ErrNo> WasiNNGetOutputSingle::bodyImpl(
 
 Expect<WASINN::ErrNo>
 WasiNNCompute::bodyImpl(const Runtime::CallingFrame &Frame, uint32_t Context) {
+#ifdef WASMEDGE_BUILD_WASI_NN_RPC
+  if (Env.NNRPCChannel != nullptr) {
+    auto Stub = wasi_ephemeral_nn::GraphExecutionContextResource::NewStub(
+        Env.NNRPCChannel);
+    grpc::ClientContext ClientContext;
+    wasi_ephemeral_nn::ComputeRequest Req;
+    Req.set_resource_handle(Context);
+    google::protobuf::Empty Res;
+    auto Status = Stub->Compute(&ClientContext, Req, &Res);
+    if (!Status.ok()) {
+      spdprintln("[WASI-NN] Failed when calling remote Compute: {}"sv,
+                    Status.error_message());
+      return WASINN::ErrNo::RuntimeError;
+    }
+    return WASINN::ErrNo::Success;
+  }
+#endif // ifdef WASMEDGE_BUILD_WASI_NN_RPC
   auto *MemInst = Frame.getMemoryByIndex(0);
   if (MemInst == nullptr) {
     return Unexpect(ErrCode::Value::HostFuncError);
@@ -369,6 +503,14 @@ WasiNNCompute::bodyImpl(const Runtime::CallingFrame &Frame, uint32_t Context) {
 Expect<WASINN::ErrNo>
 WasiNNComputeSingle::bodyImpl(const Runtime::CallingFrame &Frame,
                               uint32_t Context) {
+#ifdef WASMEDGE_BUILD_WASI_NN_RPC
+  if (Env.NNRPCChannel != nullptr) {
+    // TODO: implement RPC for ComputeSingle
+    spdprintln(
+        "[WASI-NN] RPC client is not implemented for ComputeSingle"sv);
+    return WASINN::ErrNo::UnsupportedOperation;
+  }
+#endif
   auto *MemInst = Frame.getMemoryByIndex(0);
   if (MemInst == nullptr) {
     return Unexpect(ErrCode::Value::HostFuncError);
@@ -393,6 +535,13 @@ WasiNNComputeSingle::bodyImpl(const Runtime::CallingFrame &Frame,
 Expect<WASINN::ErrNo>
 WasiNNFiniSingle::bodyImpl(const Runtime::CallingFrame &Frame,
                            uint32_t Context) {
+#ifdef WASMEDGE_BUILD_WASI_NN_RPC
+  if (Env.NNRPCChannel != nullptr) {
+    // TODO: implement RPC for FiniSingle
+    spdprintln("[WASI-NN] RPC client is not implemented for FiniSingle"sv);
+    return WASINN::ErrNo::UnsupportedOperation;
+  }
+#endif
   auto *MemInst = Frame.getMemoryByIndex(0);
   if (MemInst == nullptr) {
     return Unexpect(ErrCode::Value::HostFuncError);
diff --git a/test/plugins/wasi_nn/CMakeLists.txt b/test/plugins/wasi_nn/CMakeLists.txt
index e7eb03c5c74..fe68a8faeed 100644
--- a/test/plugins/wasi_nn/CMakeLists.txt
+++ b/test/plugins/wasi_nn/CMakeLists.txt
@@ -100,3 +100,11 @@ else()
 endif()
 
 add_test(wasiNNTests wasiNNTests)
+
+if(WASMEDGE_BUILD_WASI_NN_RPC)
+  add_definitions(-DWASMEDGE_BUILD_WASI_NN_RPC)
+  target_link_libraries(wasiNNTests
+    PRIVATE
+    wasiNNRPC
+  )
+endif()
\ No newline at end of file
diff --git a/test/plugins/wasi_nn/wasi_nn.cpp b/test/plugins/wasi_nn/wasi_nn.cpp
index 58d6ea7c3ca..0285765105b 100644
--- a/test/plugins/wasi_nn/wasi_nn.cpp
+++ b/test/plugins/wasi_nn/wasi_nn.cpp
@@ -21,12 +21,18 @@ using WasmEdge::Host::WASINN::ErrNo;
     defined(WASMEDGE_PLUGIN_WASI_NN_BACKEND_TFLITE) ||                         \
     defined(WASMEDGE_PLUGIN_WASI_NN_BACKEND_GGML)
 namespace {
-WasmEdge::Runtime::Instance::ModuleInstance *createModule() {
+WasmEdge::Runtime::Instance::ModuleInstance *
+createModule(std::string_view NNRPCURI = "") {
   using namespace std::literals::string_view_literals;
   WasmEdge::Plugin::Plugin::load(std::filesystem::u8path(
       "../../../plugins/wasi_nn/"
       "libwasmedgePluginWasiNN" WASMEDGE_LIB_EXTENSION));
   if (const auto *Plugin = WasmEdge::Plugin::Plugin::find("wasi_nn"sv)) {
+    WasmEdge::PO::ArgumentParser Parser;
+    Plugin->registerOptions(Parser);
+    if (NNRPCURI != "") {
+      Parser.set_raw_value<std::string>("nn-rpc-uri"sv, std::string(NNRPCURI));
+    }
     if (const auto *Module = Plugin->findModule("wasi_nn"sv)) {
       return Module->create().release();
     }
@@ -1465,4 +1471,208 @@ TEST(WasiNNTest, GGMLBackend) {
     EXPECT_GE(BytesWritten, 50);
   }
 }
+#ifdef WASMEDGE_BUILD_WASI_NN_RPC
+TEST(WasiNNTest, GGMLBackendWithRPC) {
+  // wasi_nn_rpcserver has to be started outside this test,
+  // and the URI has to be set to $WASI_NN_RPC_TEST_URI.
+  // nn-preload has to be specified for "default".
+  /*
+    DIR=/tmp/build
+    export WASI_NN_RPC_TEST_URI=unix://${DIR}/wasi_nn_rpc.sock
+    export WASMEDGE_PLUGIN_PATH=${DIR}/plugins/wasi_nn
+    ${DIR}/tools/wasmedge/wasi_nn_rpcserver \
+      --nn-rpc-uri=$WASI_NN_RPC_TEST_URI \
+      --nn-preload=default:GGML:AUTO:${DIR}/test/plugins/wasi_nn/wasinn_ggml_fixtures/orca_mini.gguf
+  */
+  const auto NNRPCURI = ::getenv("WASI_NN_RPC_TEST_URI");
+  if (NNRPCURI == nullptr) {
+    GTEST_SKIP() << "WASI_NN_RPC_TEST_URI is unset";
+  }
+
+  // Create the wasmedge_process module instance.
+  auto *NNMod =
+      dynamic_cast<WasmEdge::Host::WasiNNModule *>(createModule(NNRPCURI));
+  EXPECT_FALSE(NNMod == nullptr);
+
+  // Create the calling frame with memory instance.
+  WasmEdge::Runtime::Instance::ModuleInstance Mod("");
+  Mod.addHostMemory(
+      "memory", std::make_unique<WasmEdge::Runtime::Instance::MemoryInstance>(
+                    WasmEdge::AST::MemoryType(60000)));
+  auto *MemInstPtr = Mod.findMemoryExports("memory");
+  ASSERT_TRUE(MemInstPtr != nullptr);
+  auto &MemInst = *MemInstPtr;
+  WasmEdge::Runtime::CallingFrame CallFrame(nullptr, &Mod);
+
+  std::string Prompt = "Once upon a time, ";
+  std::vector<uint8_t> TensorData(Prompt.begin(), Prompt.end());
+
+  std::vector<uint32_t> TensorDim{1};
+  uint32_t BuilderPtr = UINT32_C(0);
+  uint32_t LoadEntryPtr = UINT32_C(0);
+  uint32_t SetInputEntryPtr = UINT32_C(0);
+  uint32_t OutBoundPtr = UINT32_C(61000) * UINT32_C(65536);
+  uint32_t StorePtr = UINT32_C(65536);
+
+  // Return value.
+  std::array<WasmEdge::ValVariant, 1> Errno = {UINT32_C(0)};
+
+  // Get the function "load_by_name".
+  auto FuncInst = NNMod->findFuncExports("load_by_name");
+  EXPECT_NE(FuncInst, nullptr);
+  EXPECT_TRUE(FuncInst->isHostFunction());
+  auto &HostFuncLoadByName =
+      dynamic_cast<WasmEdge::Host::WasiNNLoadByName &>(FuncInst->getHostFunc());
+  // Get the function "init_execution_context".
+  FuncInst = NNMod->findFuncExports("init_execution_context");
+  EXPECT_NE(FuncInst, nullptr);
+  EXPECT_TRUE(FuncInst->isHostFunction());
+  auto &HostFuncInit = dynamic_cast<WasmEdge::Host::WasiNNInitExecCtx &>(
+      FuncInst->getHostFunc());
+  // Get the function "set_input".
+  FuncInst = NNMod->findFuncExports("set_input");
+  EXPECT_NE(FuncInst, nullptr);
+  EXPECT_TRUE(FuncInst->isHostFunction());
+  auto &HostFuncSetInput =
+      dynamic_cast<WasmEdge::Host::WasiNNSetInput &>(FuncInst->getHostFunc());
+  // Get the function "get_output".
+  FuncInst = NNMod->findFuncExports("get_output");
+  EXPECT_NE(FuncInst, nullptr);
+  EXPECT_TRUE(FuncInst->isHostFunction());
+  auto &HostFuncGetOutput =
+      dynamic_cast<WasmEdge::Host::WasiNNGetOutput &>(FuncInst->getHostFunc());
+  // Get the function "compute".
+  FuncInst = NNMod->findFuncExports("compute");
+  EXPECT_NE(FuncInst, nullptr);
+  EXPECT_TRUE(FuncInst->isHostFunction());
+  auto &HostFuncCompute =
+      dynamic_cast<WasmEdge::Host::WasiNNCompute &>(FuncInst->getHostFunc());
+
+  // Test: load_by_name -- load successfully.
+  {
+    std::string Name = "default";
+    std::vector<char> NameVec(Name.begin(), Name.end());
+    writeBinaries<char>(MemInst, NameVec, LoadEntryPtr);
+    EXPECT_TRUE(HostFuncLoadByName.run(
+        CallFrame,
+        std::initializer_list<WasmEdge::ValVariant>{
+            LoadEntryPtr, static_cast<uint32_t>(NameVec.size()), BuilderPtr},
+        Errno));
+    EXPECT_EQ(Errno[0].get<int32_t>(), static_cast<uint32_t>(ErrNo::Success));
+    EXPECT_EQ(*MemInst.getPointer<uint32_t *>(BuilderPtr), 0);
+    BuilderPtr += 4;
+  }
+
+  // GGML WASI-NN init_execution_context tests.
+  // Test: init_execution_context -- graph id invalid.
+  {
+    EXPECT_TRUE(HostFuncInit.run(
+        CallFrame,
+        std::initializer_list<WasmEdge::ValVariant>{UINT32_C(2), BuilderPtr},
+        Errno));
+    EXPECT_NE(Errno[0].get<int32_t>(), static_cast<uint32_t>(ErrNo::Success));
+  }
+
+  // Test: init_execution_context -- init context successfully.
+  {
+    EXPECT_TRUE(HostFuncInit.run(
+        CallFrame,
+        std::initializer_list<WasmEdge::ValVariant>{UINT32_C(0), BuilderPtr},
+        Errno));
+    EXPECT_EQ(Errno[0].get<int32_t>(), static_cast<uint32_t>(ErrNo::Success));
+    EXPECT_EQ(*MemInst.getPointer<uint32_t *>(BuilderPtr), 0);
+    BuilderPtr += 4;
+  }
+
+  // GGML WASI-NN set_input tests.
+  SetInputEntryPtr = BuilderPtr;
+  writeFatPointer(MemInst, StorePtr, TensorDim.size(), BuilderPtr);
+  writeUInt32(MemInst, UINT32_C(1), BuilderPtr);
+  writeFatPointer(MemInst, StorePtr + TensorDim.size() * 4, TensorData.size(),
+                  BuilderPtr);
+  writeBinaries<uint32_t>(MemInst, TensorDim, StorePtr);
+  writeBinaries<uint8_t>(MemInst, TensorData, StorePtr + TensorDim.size() * 4);
+
+  // Test: set_input -- context id exceeds.
+  {
+    EXPECT_TRUE(
+        HostFuncSetInput.run(CallFrame,
+                             std::initializer_list<WasmEdge::ValVariant>{
+                                 UINT32_C(3), UINT32_C(0), SetInputEntryPtr},
+                             Errno));
+    EXPECT_NE(Errno[0].get<int32_t>(), static_cast<uint32_t>(ErrNo::Success));
+  }
+
+  // Test: set_input -- set input successfully.
+  BuilderPtr = SetInputEntryPtr;
+  writeFatPointer(MemInst, StorePtr, TensorDim.size(), BuilderPtr);
+  writeUInt32(MemInst, UINT32_C(1), BuilderPtr);
+  writeFatPointer(MemInst, StorePtr + TensorDim.size() * 4, TensorData.size(),
+                  BuilderPtr);
+  {
+    EXPECT_TRUE(
+        HostFuncSetInput.run(CallFrame,
+                             std::initializer_list<WasmEdge::ValVariant>{
+                                 UINT32_C(0), UINT32_C(0), SetInputEntryPtr},
+                             Errno));
+    EXPECT_EQ(Errno[0].get<int32_t>(), static_cast<uint32_t>(ErrNo::Success));
+  }
+  StorePtr += (TensorDim.size() * 4 + TensorData.size());
+
+  // GGML WASI-NN compute tests.
+  // Test: compute -- context id exceeds.
+  {
+    EXPECT_TRUE(HostFuncCompute.run(
+        CallFrame, std::initializer_list<WasmEdge::ValVariant>{UINT32_C(3)},
+        Errno));
+    EXPECT_NE(Errno[0].get<int32_t>(), static_cast<uint32_t>(ErrNo::Success));
+  }
+
+  // Test: compute -- compute until finish or context full.
+  {
+    EXPECT_TRUE(HostFuncCompute.run(
+        CallFrame, std::initializer_list<WasmEdge::ValVariant>{UINT32_C(0)},
+        Errno));
+    // FIXME: ErrNo propagation is not supported yet
+    //    EXPECT_TRUE(
+    //        Errno[0].get<int32_t>() == static_cast<uint32_t>(ErrNo::Success)
+    //        || Errno[0].get<int32_t>() ==
+    //        static_cast<uint32_t>(ErrNo::ContextFull));
+  }
+
+  // GGML WASI-NN get_output tests.
+  // Test: get_output -- output bytes ptr out of bounds.
+  {
+    EXPECT_TRUE(HostFuncGetOutput.run(
+        CallFrame,
+        std::initializer_list<WasmEdge::ValVariant>{
+            UINT32_C(0), UINT32_C(0), StorePtr, 65532, OutBoundPtr},
+        Errno));
+    EXPECT_NE(Errno[0].get<int32_t>(), static_cast<uint32_t>(ErrNo::Success));
+  }
+
+  // Test: get_output -- output buffer ptr out of bounds.
+  {
+    EXPECT_TRUE(HostFuncGetOutput.run(
+        CallFrame,
+        std::initializer_list<WasmEdge::ValVariant>{
+            UINT32_C(0), UINT32_C(0), OutBoundPtr, 65532, BuilderPtr},
+        Errno));
+    EXPECT_NE(Errno[0].get<int32_t>(), static_cast<uint32_t>(ErrNo::Success));
+  }
+
+  // Test: get_output -- get output successfully.
+  {
+    EXPECT_TRUE(HostFuncGetOutput.run(
+        CallFrame,
+        std::initializer_list<WasmEdge::ValVariant>{
+            UINT32_C(0), UINT32_C(0), StorePtr, 65532, BuilderPtr},
+        Errno));
+    EXPECT_EQ(Errno[0].get<int32_t>(), static_cast<uint32_t>(ErrNo::Success));
+    // Should output more than 50 bytes.
+    auto BytesWritten = *MemInst.getPointer<uint32_t *>(BuilderPtr);
+    EXPECT_GE(BytesWritten, 50);
+  }
+}
+#endif // WASMEDGE_BUILD_WASI_NN_RPC
 #endif // WASMEDGE_PLUGIN_WASI_NN_BACKEND_GGML
diff --git a/tools/wasmedge/CMakeLists.txt b/tools/wasmedge/CMakeLists.txt
index ea774da4454..a886510d4cb 100644
--- a/tools/wasmedge/CMakeLists.txt
+++ b/tools/wasmedge/CMakeLists.txt
@@ -43,3 +43,34 @@ else()
   )
 endif()
 
+
+if(WASMEDGE_BUILD_WASI_NN_RPC)
+  wasmedge_add_executable(wasi_nn_rpcserver
+    wasi_nn_rpcserver.cpp
+  )
+
+  target_include_directories(wasi_nn_rpcserver
+    SYSTEM BEFORE PUBLIC ${Protobuf_INCLUDE_DIR}
+  )
+
+  install(TARGETS wasi_nn_rpcserver EXPORT wasi_nn_rpcserver
+    DESTINATION ${CMAKE_INSTALL_BINDIR}
+  )
+
+  if(WASMEDGE_LINK_TOOLS_STATIC)
+    target_link_libraries(wasi_nn_rpcserver
+      PRIVATE
+      wasmedgeCAPI
+    )
+  else()
+    target_link_libraries(wasi_nn_rpcserver
+      PRIVATE
+      wasmedge_shared
+    )
+  endif()
+
+  target_compile_options(wasi_nn_rpcserver
+    PUBLIC
+    -DWASMEDGE_BUILD_WASI_NN_RPC
+  )
+endif()
diff --git a/tools/wasmedge/wasi_nn_rpcserver.cpp b/tools/wasmedge/wasi_nn_rpcserver.cpp
new file mode 100644
index 00000000000..f740101eaf9
--- /dev/null
+++ b/tools/wasmedge/wasi_nn_rpcserver.cpp
@@ -0,0 +1,20 @@
+// SPDX-License-Identifier: Apache-2.0
+// SPDX-FileCopyrightText: 2019-2022 Second State INC
+
+#include "wasmedge/wasmedge.h"
+
+#if defined(_WIN32) || defined(_WIN64) || defined(__WIN32__) ||                \
+    defined(__TOS_WIN__) || defined(__WINDOWS__)
+extern "C" int wmain(int Argc, const wchar_t *Argv[]);
+int wmain(int Argc, const wchar_t *Argv[]) {
+  WasmEdge_Driver_SetConsoleOutputCPtoUTF8();
+  auto NewArgv = WasmEdge_Driver_ArgvCreate(Argc, Argv);
+  const int Result = WasmEdge_Driver_WasiNNRPCServer(Argc, NewArgv);
+  WasmEdge_Driver_ArgvDelete(NewArgv);
+  return Result;
+}
+#else
+int main(int Argc, const char *Argv[]) {
+  return WasmEdge_Driver_WasiNNRPCServer(Argc, Argv);
+}
+#endif

